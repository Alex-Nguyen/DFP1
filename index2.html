<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Malware Visualization</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>
    <style>
        line {
            stroke: #999;
            stroke-opacity: .6;
        }

        .dllline {
            stroke: #000;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            width: 150px;
            height: 40px;
            padding: 2px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
<fieldset>
    <legend>Data Overview - Number of API calls in each type</legend>
    <div id="stats"></div>
</fieldset>

<fieldset>
    <legend>
        Heat Map
    </legend>
    <div id="heatmap"></div>
    <div id="domain"></div>
</fieldset>

<script>
    var div = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
    d3.queue()
    //.defer(d3.csv, "data/log1data.csv", function (d) {
    //.defer(d3.csv, "data/Logfile_Test2.csv", function (d) {
        .defer(d3.csv, "data/Logfile_Test2.csv", function (d) {
            return {
                Timestamp: d['Time_of_Day'],
                PID: d['PID'],
                Process_Name: d['Process_Name'],
                Operation: d["Operation"],
                Path: d["Path"],
                Detail: d["Detail"]
            }
        })
        .defer(d3.csv, "data/domain.csv")
        .await(function (error, data, domain) {
            if (error) {
                console.error('Oh dear, something went wrong: ' + error);
            }
            else {
                var normalOSProcess = ['MsMpEng',
                    'AUDIODG', 'taskhostw', 'RuntimeBroker', 'sihost']
                // data = data.filter(function (d) {
                //     if (!normalOSProcess.includes(d.Process_Name.slice(0, -4))) {
                //         return d;
                //     }
                // })
                // Process Data before visualization
                var domainFormat = /[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+/;
                var previous_minute = +data[0].Timestamp.slice(2, 4);
                var previous_second = +data[0].Timestamp.slice(5, 7);
                var previous_milisecond = +data[0].Timestamp.slice(8, 11);
                var metrics = 1000;
                var previous_time_step = (previous_minute * 60 + previous_second) * metrics + previous_milisecond;
                var current_time_step = 0;


                data.forEach(function (datum, index) {
                    datum.minute = +datum.Timestamp.slice(2, 4);
                    datum.second = +datum.Timestamp.slice(5, 7);
                    datum.milisecond = +datum.Timestamp.slice(8, 11);
                    datum.Step = (datum.minute *60 + datum.second) * metrics + datum.milisecond - previous_time_step + current_time_step;
                    current_time_step = datum.Step;
                    previous_time_step = (datum.minute *60 + datum.second) * metrics + datum.milisecond;
                    if (datum.Operation == 'Process Create') {
                        datum.targetProcessName = datum.Path.replace(/^.*[\\\/]/, '');
                        datum.childPID = datum.Detail.slice(5, 9);
                    }
                    if (datum.Operation == 'UDP Send') {

                        var getdomain = datum.Path.slice(datum.Path.indexOf('->') + 3, -5);
                        if (getdomain.match(domainFormat)) {
                            if (getdomain.split('.').length > 2) {
                                getdomain = getdomain.slice(getdomain.indexOf('.') + 1);
                                datum.Domain = getdomain;
                            } else {
                                datum.Domain = getdomain;
                            }
                            domain.forEach(function (dm_value) {
                                if (dm_value.domain == datum.Domain) {
                                    var obj = {}
                                    obj.count = +dm_value.count;
                                    obj.harmless = +dm_value.harmless;
                                    obj.malicious = +dm_value.malicious;
                                    obj.suspicious = +dm_value.suspicious;
                                    obj.undetected = +dm_value.undetected;
                                    datum.VirusTotal = obj;
                                }
                            })
                        }

                    }
                    if (datum.Path.slice(-3).toLowerCase() == 'dll') {
                        datum.library = datum.Path.replace(/^.*[\\\/]/, '')
                    }
                    datum.Process = getProcessName(datum.Operation);
                });
                // End of pre-processing data

                // Load Statistics data on the first box
                LoadStats();
                loadProcessByName();
                function LoadStats() {
                    var margin_left = 120;
                    var bar_height = 35;
                    var group_by_process = d3.nest().key(function (d) {
                        return d.Process
                    }).entries(data)
                    var xScale = d3.scaleLinear()
                        .domain([0, d3.max(group_by_process, function (d) {
                            return d.values.length;
                        })])
                        .range([10, 1000]);
                    var svgStats = d3.select('#stats').append('svg').attr('width', window.innerWidth).attr('height', 200);
                    group_by_process.forEach(function (process, index) {
                        var group = svgStats.append('g').attr("transform", "translate(0," + index * bar_height + ")");
                        var child_process = d3.nest().key(function (d) {
                            return d.Operation
                        }).entries(process.values);
                        child_process = child_process.sort(function (a, b) {
                            return b.values.length - a.values.length;
                        })
                        var xpos = margin_left;

                        child_process.forEach(function (child) {
                            group.append('rect').attr('x', function (d) {
                                return xpos;
                            })
                                .attr('width', function (d) {
                                    return xScale(child.values.length)
                                })
                                .attr('height', 30)
                                .attr('class', child.key)
                                .attr('fill', function (d) {
                                    return colorPicker(child.key);
                                }).on('mouseover', function (d) {
                                div.transition()
                                    .duration(200)
                                    .style("opacity", .9);
                                div.html('Operation: '+child.key + "<br/> Total calls:" + child.values.length + "<br/>")
                                    .style("left", (d3.event.pageX) + 5 + "px")
                                    .style("top", (d3.event.pageY - 28) + "px");
                            }).on("click", function (d) {
                                var allrect = d3.select("#heatmap").selectAll('rect[group=detail]').style('opacity', 0);
                                d3.select("#heatmap").selectAll('rect.' + child.key.replace(" ", "_")).style('opacity', 1);
                            });
                            ;
                            xpos += xScale(child.values.length) + 2;
                        })
                        group.append('text').text(process.key + " (" + process.values.length + ")").attr('x', 0).attr('y', 18);
                    })
                    var group_O = svgStats.append('g').attr('transform', 'translate('+ window.innerWidth*0.85+',0)')
                    var group_by_operation = [{'key': 'WriteFile'}, {'key': 'CreateFile'}, {'key': 'SetRenameInformationFile'}, {'key': 'Load Image'}, {'key': 'Process Create'},
                        {'key': 'RegCreateKey'}, {'key': 'RegDeleteValue'}, {'key': 'RegDeleteKey'}, {'key': 'UDP Send'}, {'key': 'UDP Receive'}, {'key': 'TCP Receive'}, {'key': 'TCP Send'}, {'key': 'TCP Connect'}]

                    group_by_operation.forEach(function (operation, index) {
                        var rect = group_O.append('g').attr('transform', 'translate(0,' + index * 15 + ')');
                        rect.append('rect').attr('width', '20px').attr('height', '12px').attr('fill', function (d) {
                            return colorPicker(operation.key);
                        })
                        rect.append('text').text(operation.key).attr('x', '30px').style('color', 'black').style('font-size', '12px').attr('y', '8px')
                    })
                }

                function loadProcessByName() {
                    d3.select('#heatmap').selectAll("*").remove();
                    var lines = [];
                    var group_by_process_name = d3.nest().key(function (d) {
                        return d.Process_Name

                    }).entries(data);
                    // console.log(getChildName(group_by_process_name[0].values))


                    var group_by_process_create = d3.nest().key(function (d) {
                        return d.Operation;

                    }).entries(data)
                    group_by_process_create = group_by_process_create.filter(function (value) {
                        return value.key == 'Process Create'
                    })[0].values;
                    //YOUR DATA YOU NEED HERE -> UPDATED DATA
                    var updated_data = UpdateProcessNameWithChild(group_by_process_name, group_by_process_create);
                    for (var i = 0; i < updated_data.length; i++) {
                        updated_data[i].children = [];
                        for (var j = 0; j < updated_data[i].childs.length; j++) {
                            var obj = updated_data[updated_data[i].childs[j]];
                            updated_data[i].children.push(obj);
                        }
                        // sort children
                        updated_data[i].children.sort(function (a, b) {
                            if (a.childs.length < b.childs.length) {
                                return -1;
                            }
                            else if (a.childs.length > b.childs.length) {
                                return 1;
                            }
                            else {
                                if (a.values[0].Step < b.values[0].Step) {
                                    return 1;
                                }
                                else if (a.values[0].Step > b.values[0].Step) {
                                    return -1;
                                }
                                else
                                    return 0;
                            }
                        });
                    }

                    updated_data.sort(function (a, b) {
                        if (getSuccessors(a, []).length < getSuccessors(b, []).length) {
                            return 1;
                        }
                        else if (getSuccessors(a, []).length > getSuccessors(b, []).length) {
                            return -1;
                        }
                        else {
                            if (a.values[0].Step < b.values[0].Step) {
                                return -1;
                            }
                            else if (a.values[0].Step > b.values[0].Step) {
                                return 1;
                            }
                            else
                                return 0;
                        }
                    });
                    var orderedArray = [];
                    var nextIndex = 0;

                    for (var i = 0; i < updated_data.length; i++) {
                        dfs(updated_data[i], orderedArray);
                    }

                    // DFS
                    function dfs(o, array) {
                        if (o.isDone == undefined) {
                            array.push(o);
                            o.isDone = true;
                            if (o.children != undefined) {
                                for (var i = 0; i < o.children.length; i++) {
                                    dfs(o.children[i], array);
                                }
                            }
                        }
                    }

                    // DFS
                    function getSuccessors(o, array) {
                        if (o.children != undefined) {
                            for (var i = 0; i < o.children.length; i++) {
                                array.push(o.children[i]);
                            }
                            for (var i = 0; i < o.children.length; i++) {
                                getSuccessors(o.children[i], array)
                            }
                        }
                        return array;
                    }

                    group_by_process_name.forEach(function (d) {
                        d.position = getProcessNameIndex(orderedArray, d.key);
                    })
                    group_by_process_name = group_by_process_name.sort(function (a, b) {
                        return a.position - b.position;
                    });
                    // orderedArray is the topological ordering
                    //  debugger;

                    var margin_left = 20;
                    var rect_height = 20, rect_margin_top = 5, group_rect_height = rect_height + rect_margin_top,
                        rect_width = 0.9;
                    var svgheight = group_by_process_name.length * (group_rect_height);
                    var max_step = d3.max(data, function (d) {
                        return d.Step;
                    });
                    var max_scale = window.innerWidth *0.7;
                    var StepScale = d3.scaleLinear()
                        .domain([0, max_step])
                        .range([0, max_scale]);

                    var library = d3.nest().key(function (d) {
                        return d.library
                    }).entries(data)

                    library = library.filter(function (value) {
                        if (value.key != 'undefined' && value.values.length > 60) return value
                    })
                    var libarr = [];
                    library.forEach(function (d) {
                        libarr.push(d.key);
                    })
                    library = library.sort(function (a,b) { return b.values.length - a.values.length })

                    var svg_process_name = d3.select('#heatmap').append('svg').attr('width', window.innerWidth).attr('height', svgheight);
                    svg_process_name.append("svg:defs").append("svg:marker")
                        .attr("id", "arrow")
                        .attr("refX", 0)
                        .attr("refY", 4)
                        .attr("markerWidth", 8)
                        .attr("markerHeight", 8).attr('fill', 'rgb(37, 142, 215)')
                        .attr("orient", 0).append('path').attr('d', 'M0,0 L0,8 L8,4 z');

                    group_by_process_name.forEach(function (row, index) {
                        var group = svg_process_name.append('g').attr("transform", "translate(0," + index * group_rect_height + ")");

                        group.append('line').attr('stroke-dasharray', '2, 5').attr('stroke', 'black').attr('stroke-width', 0.1)
                            .attr('x1', (StepScale(row.values[0].Step) * rect_width + margin_left + 10)).attr('y1', rect_height / 2)
                            .attr('x2', (((StepScale(row.values[row.values.length - 1].Step)) * rect_width + margin_left) + 10)).attr('y2', rect_height / 2);

                        var processes = row.values.filter(function (filter) {
                            if (filter.hasOwnProperty('library') && libarr.includes(filter.library) == true) return filter;
                        })
                        var filtered_library = d3.nest().key(function (d) {
                            return d.library
                        }).entries(processes)

                        filtered_library.forEach(function (d) {
                            var obj = {};
                            obj.source = index;
                            obj.target = libarr.indexOf(d.key);
                            obj.value = d.values.length;
                            lines.push(obj);
                        })


                        group.append('rect').attr('x', max_scale +20).attr('width', 40)
                            .attr('index', index)
                            .attr('height', rect_height).attr('id', row.key.slice(0, -4).toLowerCase()).attr('fill', 'darkgray')
                            .on('click', function (d) {
                                d3.selectAll("line.dllline").style('opacity', 0)
                                lines = d3.selectAll('line[source="' + index + '"]').style('opacity', 1);

                            });

                        group.append('text').text(row.key.substring(0,20))
                            .attr('x', ((StepScale(row.values[row.values.length - 1].Step)) * rect_width + margin_left) + 10).attr('y', group_rect_height/2)
                            .attr('text-anchor', 'start');


                        // group.append('text').text(row.key.substring(0,20))
                        //     .attr('x', max_scale +400).attr('y', 18)
                        //     .attr('text-anchor', 'end');

                        var rect = group.selectAll('rect').data(row.values).enter().append('rect')
                            .attr('x', function (d, i) {
                                return (StepScale(d.Step)) * rect_width + margin_left;
                            })
                            .attr('class', function (d, i) {
                                return d.Operation.replace(" ", "_");
                            })
                            .attr('group','detail')
                            .attr('id', function (d) {
                                return d.Step;
                            }).attr('y', function (d) {
                                if (d.hasOwnProperty('VirusTotal')) {
                                    if (d.VirusTotal.malicious > 0)
                                        return 0;
                                }
                                else {
                                    return 2.5;
                                }
                            })
                            .attr('width', rect_width)
                            .attr('height', function (d) {
                                if (d.hasOwnProperty('VirusTotal')) {
                                    if (d.VirusTotal.malicious > 0)
                                        return rect_height;
                                }
                                else {
                                    return rect_height - 5;
                                }
                            })
                            .style('fill-opacity', 0.6)
                            .attr('fill', function (d) {
                                return colorPicker(d.Operation);
                            }).on('mouseover', function (d) {
                                if (d.Operation == 'UDP Send' && d.hasOwnProperty('VirusTotal')) {

                                    div.transition()
                                        .duration(200)
                                        .style("opacity", 1).style('height', '100px').style('width', '250px');
                                    div.html('<table><tr><td colspan="4">Source: https://www.virustotal.com</td></tr><tr><td><img src="images/clean.png" width="20" height="20"/></td><td> Clean (' + d.VirusTotal.harmless + ')</td>' +
                                        '<td><img src="images/malicious.png" width="20" height="20"/></td><td><font color="red"><b>Malicious (' + d.VirusTotal.malicious + ')</b> </font></td></tr>' +
                                        '<tr><td><img src="images/suspicious.png" width="20" height="20"/></td><td> Suspicious (' + d.VirusTotal.suspicious + ')</td>' +
                                        '<td><img src="images/question.png" width="20" height="20"/></td><td> Undetected (' + d.VirusTotal.undetected + ')</td></tr><tr><td colspan="4">Target domain: ' + d.Domain + '</td></tr></table>')
                                        .style("left", (d3.event.pageX) + "px")
                                        .style("top", (d3.event.pageY - 28) + "px");
                                }
                                else {


                                    div.transition()
                                        .duration(200)
                                        .style("opacity", 1);
                                    div.html(d.Process_Name + "<br/>" + d.Timestamp + "<br/>")
                                        .style("left", (d3.event.pageX) +10+ "px")
                                        .style("top", (d3.event.pageY - 28) + "px");

                                }
                            }).on('click',function (d) {
                                var paths = d3.selectAll('path.detail_path').style('opacity',0);
                                d3.selectAll('path[source="' + (getProcessNameIndex(updated_data, d.Process_Name)) + '"]').style('opacity', 1);
                                console.log(d)
                            })
                    })


                    orderedArray.forEach(function (d, index) {
                        if (d.children.length > 0) {
                            d.children.forEach(function (child) {
                                svg_process_name.append('path').attr("class",'detail_path')
                                    .attr('d', d3.arc()
                                        .innerRadius((getProcessNameIndex(updated_data, child.key) - index) * group_rect_height / 2 -1)
                                        .outerRadius((getProcessNameIndex(updated_data, child.key) - index) * group_rect_height / 2 )
                                        .startAngle(-Math.PI) //converting from degs to radians
                                        .endAngle(Math.PI / 90))
                                    .attr('fill', 'rgb(37, 142, 215)').attr('source',index).attr('target',getProcessNameIndex(updated_data, child.key))
                                    .attr('transform', function (value) {
                                        var posX = (StepScale(child.values[0].Step)) * rect_width + margin_left - 5;
                                        var posY = (getProcessNameIndex(updated_data, child.key) + index) * group_rect_height / 2 + group_rect_height/2;
                                        return 'translate(' + posX + ',' + posY + ')';
                                    }).attr("marker-end", "url(#arrow)")

                            })

                        }

                    })

                    var dllGroup = svg_process_name.append('g').attr("transform", "translate("+(window.innerWidth-210)+",0)");
                    var number_of_dll = library.length;
                    var padding = 10;
                    var dll_height = (svgheight - padding * (number_of_dll)) / number_of_dll;

                    var rectDLL = dllGroup.selectAll('rect').data(library).enter()
                    rectDLL.append('rect').attr('x', 0).attr('y', function (d, i) {
                        return i * (dll_height + padding);
                    }).attr('width', 40).attr('height', dll_height).attr('fill', 'darkgray').attr('id', function (d) {
                        return d.key.slice(0, -4);
                    }).attr('index', function (d, i) {
                        return i;
                    })
                    rectDLL.append('text').text(function (d) {
                        return d.key.substring(0,20) + '(' + d.values.length + ')';
                    }).attr('x', 50).attr('y', function (d, i) {
                        return i * (dll_height + padding) + (dll_height + padding) / 2;
                    });
                    var ddlLineScale = d3.scaleLinear()
                        .domain([d3.min(lines, function (d) {
                            return d.value;
                        }), d3.max(lines, function (d) {
                            return d.value;
                        })])
                        .range([0.5, 3]);


                    var dllLines = svg_process_name.append('g');
                    for (var i = 0; i < lines.length; i++) {
                        dllLines.append('line').attr('stroke-width', ddlLineScale(lines[i].value)).attr('class', 'dllline')
                            .attr('x1', max_scale+60).attr('source', lines[i].source).attr('target', lines[i].target).attr('y1', lines[i].source * group_rect_height + rect_height / 2)
                            .attr('x2', window.innerWidth-210).attr('y2', lines[i].target * ((dll_height + padding)) + (dll_height + padding) / 4)
                    }
                }


            }
        });

    function getProcessName(operation) {
        switch (operation) {
            case "Process Create":
                return "Process";
            case "Load Image":
                return "Process";
            case "CreateFile":
                return "File";
            case "WriteFile":
                return "File";
            case "SetRenameInformationFile":
                return "File";
            case "RegCreateKey":
                return "Registry";
            case "RegDeleteValue":
                return "Registry";
            case "RegDeleteKey":
                return "Registry";
            case "UDP Send":
                return "Network";
            case "UDP Receive":
                return "Network";
            case "TCP Receive":
                return "Network";
            case "TCP Connect":
                return "Network";
            case "TCP Send":
                return "Network";

        }
    }

    function colorPicker(operation) {
        switch (operation) {
            case "Process Create":
                return "rgb(37, 142, 215)";
            case "Load Image":
                return "rgb(31, 119, 180)";
            case "CreateFile":
                return "rgb(255, 152, 17)";
            case "WriteFile":

                return "rgb(255, 127, 14)";
            case "SetRenameInformationFile":
                return "rgb(255, 181, 20)";
            case "RegCreateKey":
                return "rgb(44, 160, 44)";
            case "RegDeleteValue":
                return "rgb(53, 191, 53)";
            case "RegDeleteKey":
                return "rgb(63, 229, 63)";
            case "UDP Send":
                return "rgb(214, 39, 40)";
            case "UDP Receive":
                return "rgb(255, 47, 48)";
            case "TCP Receive":
                return "rgb(255, 56, 57)";
            case "TCP Connect":
                return "rgb(255, 80, 82)";
            case "TCP Send":
                return "rgb(255, 67, 68)";
            default:
                return "#000000";
        }
    }

    function UpdateProcessNameWithChild(processLst, links) {
        processLst.forEach(function (proc, parentIndex) {
            proc.childs = [];
            links.forEach(function (link) {
                if (proc.key == link.Process_Name) {
                    var index = getProcessNameIndex(processLst, link.targetProcessName);

                    if (!proc.childs.includes(index) && index != parentIndex) {
                        //Check for loop insertion
                        if (processLst[index].hasOwnProperty('childs')) {
                            if (!processLst[index].childs.includes(parentIndex)) {
                                proc.childs.push(index)
                            }
                        } else {
                            proc.childs.push(index)
                        }

                    }

                }
            })
        })
        return processLst;
    }

    function getProcessNameIndex(processlst, key) {
        var index;
        processlst.forEach(function (d, i) {
            if (d.key == key) {
                index = i;
            }

        })
        return index;
    }
</script>
</body>
</html>